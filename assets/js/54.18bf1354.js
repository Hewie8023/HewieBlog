(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{288:function(_,v,A){"use strict";A.r(v);var t=A(5),P=Object(t.a)({},(function(){var _=this,v=_.$createElement,A=_._self._c||v;return A("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[A("h1",{attrs:{id:"二、数据链路层"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#二、数据链路层","aria-hidden":"true"}},[_._v("#")]),_._v(" 二、数据链路层")]),_._v(" "),A("p",[_._v("负责帧数据的传递。（经过数据链路层封装的数据称为帧）")]),_._v(" "),A("h2",{attrs:{id:"_1、以太网帧格式"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_1、以太网帧格式","aria-hidden":"true"}},[_._v("#")]),_._v(" 1、以太网帧格式")]),_._v(" "),A("p",[A("img",{attrs:{src:"https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F.png",alt:""}})]),_._v(" "),A("ol",[A("li",[_._v("源地址和目的地址是指网卡的硬件地址(也叫MAC地址)，长度是48位，是在网卡出厂时固化的")]),_._v(" "),A("li",[_._v("帧协议类型字段有三种值,分别对应IP、ARP、RARP ，此变量决定了在分用过程中，网络层该利用哪个协议。")]),_._v(" "),A("li",[_._v("帧末尾是CRC校验码，循环冗余校验字段（FCS）提供了一种错误检测机制。该字段长度为4个字节")])]),_._v(" "),A("h2",{attrs:{id:"_2、mtu"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_2、mtu","aria-hidden":"true"}},[_._v("#")]),_._v(" 2、MTU")]),_._v(" "),A("p",[_._v("从上图可以看出，数据段长是1500字节，也就是说单个帧中，IP数据包必须小于1500字节，这 个1500就是MTU能达到的大值，它是数据链路层允许的大IP包。MTU的定义就是：数据链路层允许的大IP包长（最大值是1500字节）。")]),_._v(" "),A("ol",[A("li",[_._v("不同网络类型的MTU是不同的")]),_._v(" "),A("li",[_._v("以太网帧中的数据长度规定小46字节，大1500字节")]),_._v(" "),A("li",[_._v("ARP数据包的长度不够46字节,要在后面补填充位")])]),_._v(" "),A("p",[_._v("那如果数据包的长度大于1500字节呢？ 如果一个数据包从以太网路由到拨号链路上,数据包长度大于拨号链路的MTU了，则需要对数据包进行"),A("strong",[_._v("分片")]),_._v("。")]),_._v(" "),A("p",[_._v("由于以太网传输电气方面的限制，每个以太网帧小64字节，大不能超过1518字节，对于小于或者大于这个限制的以太网帧，以太网都可以视之为错误的数据帧。一般的以太网转发设备会丢弃 这些数据帧。（注：小于64字节的数据帧一般是由于以太网冲突产生的“碎片”或者线路干扰或者坏 的以太网接口产生的，对于大于1518字节的数据帧我们一般把它叫做Giant帧，这种一般是由于线 路干扰或者坏的以太网口产生）。")]),_._v(" "),A("p",[_._v("最早的以太网工作方式：在剥夺路复用/冲突检测（CSMA/CD），因为网络是共享的，即任何一个 节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。")]),_._v(" "),A("p",[A("strong",[_._v("CDMA/CD")]),_._v("\nCSMA/CD 表示载波监听多点接入 / 碰撞检测。")]),_._v(" "),A("p",[A("strong",[_._v("多点接入")]),_._v(" ：说明这是总线型网络，许多主机以多点的方式连接到总线上。")]),_._v(" "),A("p",[A("strong",[_._v("载波监听")]),_._v(" ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。")]),_._v(" "),A("p",[A("strong",[_._v("碰撞检测")]),_._v("：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。")]),_._v(" "),A("p",[_._v("记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。")]),_._v(" "),A("p",[_._v("假设A发送第一个bit位到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6us。")]),_._v(" "),A("p",[_._v("在10Mbps的网络中，在57.6us的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bit，从而让最极端的碰撞都能够被检测到。这576个bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，以太网的最小长度为64个字节。定义最小帧长度是为了使发送方能在一个帧的传输时间内检测到此帧是否在链路上产生冲突，如发生冲突，退避重发，若帧长小于最小帧，则无法检测帧传输中是否发生冲突。")]),_._v(" "),A("p",[_._v("所以说以太网的最小长度64byte是因为CSMS/CD限制所导致的，那最大长度1500byte的原因是什么？")]),_._v(" "),A("p",[_._v("IP头total length为两个byte，理论上IP packet 可以有65535byte，加上以太网帧头和尾，可以有65535+14+4=65553byte。如果在10Mbps的以太网上，将会占用共享链路长达50ms，这将严重影响其他主机的通信，特别是对延迟敏感的应用是无法接受的。")]),_._v(" "),A("p",[_._v("由于线路质量差引起的丢包，发生在大包的概率也比小包的概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。")]),_._v(" "),A("p",[_._v("但是如果选择一个较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网的长度为218byte，TCP数据包 = 218-以太网帧头和尾-IP头-TCP头 = 218-18-20-20=160byte。此时有效传输效率=160/218-73%。")]),_._v(" "),A("p",[_._v("而如果以太网长度为1518，那么有效传输效率=1460/1518=96%。")]),_._v(" "),A("p",[_._v("通过比较，选择较长的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上面的问题，于是选择一个折中的长度：1518byte，对应的IP数据包长度为1500byte，这也是最大传输单元MTU的由来。")]),_._v(" "),A("h2",{attrs:{id:"_3、arp协议"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_3、arp协议","aria-hidden":"true"}},[_._v("#")]),_._v(" 3、ARP协议")]),_._v(" "),A("p",[_._v("ARP（Address Resolution Protocol，地址解析协议）是将IP地址解析为以太网MAC地址（物理地址）的协议。")]),_._v(" "),A("p",[_._v("在局域网中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送。因此发送方还需要有接收方的物理地址，也就需要一个从IP地址到物理地址的映射，ARP就是事先这么功能的协议。")]),_._v(" "),A("h3",{attrs:{id:"_3-1工作原理"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_3-1工作原理","aria-hidden":"true"}},[_._v("#")]),_._v(" 3.1工作原理")]),_._v(" "),A("p",[A("strong",[_._v("两个主机在同一个网段中")])]),_._v(" "),A("p",[_._v("1、主机A首先查看自己的ARP表（一个IP地址与MAC地址的映射表），确定其中是否包含有主机B的IP地址和对应的MAC地址。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址对IP数据报进行帧封装，并将数据报发送给主机B。类似于计算机组成中高速缓存的命中。")]),_._v(" "),A("p",[_._v("2、如果主机A在ARP表中找不到对应的MAC地址，则先缓存该数据报文，然后以广播方式（参见数据链路层物理地址寻址部分，目的MAC地址为广播MAC地址——FFFFFF，任一同网段的节点均可收到，该网络上的所有主机）发送一个ARP请求报文，ARP请求报文中的发送端（源）IP地址和发送端MAC地址分别为主机A的IP地址和MAC地址，目的IP地址和目的MAC地址为主机B的IP地址和全0的MAC地址。ARP请求报文是以广播的形式发送，所以该网段上的所有主机都会接收到这个请求包，但只有其IP地址与目的IP地址一致的主机B会对该请求进行处理。")]),_._v(" "),A("p",[_._v("3、主机B将ARP请求报文中的发送端（主机A）的IP地址和MAC地址存入自己的ARP表中，然后以单播方式（一对一，点对点形式）向主机A发送一个ARP响应报文，应答报文中就包含了自己的MAC地址，即原来请求报文中要请求的MAC地址。")]),_._v(" "),A("p",[_._v("4、主机A在收到来自主机B的ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将原来缓存的IP数据报再次修改（在目的MAC地址子弹填上已获得的主机B的的MAC地址）后发送出去。")]),_._v(" "),A("p",[A("strong",[_._v("当两主机不在同一个网段中，其ARP地址解析过程如下")])]),_._v(" "),A("p",[_._v("1、如果主机A不知道网关（一个网络连接另一个网络的关口）的MAC地址（即主机A的ARP表没有命中），则主机A现在本网段中发出一个ARP请求广播报文，ARP请求报文中的目的IP地址为网关IP地址，代表其目的就是想获得网关的MAC地址。如果主机A已知网关MAC地址，则略过此步。")]),_._v(" "),A("p",[_._v("2、如果网关的ARP表（网关也有ARP映射表项）中已有主机B对应的MAC地址，则网关直接将在来自主机A的报文中的目的MAC地址字段填上主机B的MAC地址后转发给主机B。")]),_._v(" "),A("p",[_._v("3、如果网关ARP中没有，那么网关会再次向主机B所在网段发送ARP广播请求报文，此时目的IP地址为主机B的IP地址，其后续处理同前。")]),_._v(" "),A("h3",{attrs:{id:"_3-2arp数据包消息格式"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_3-2arp数据包消息格式","aria-hidden":"true"}},[_._v("#")]),_._v(" 3.2ARP数据包消息格式")]),_._v(" "),A("p",[A("img",{attrs:{src:"https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png",alt:""}})]),_._v(" "),A("p",[_._v("硬件类型：表示ARP报文可以在哪种类型的网络上传输")]),_._v(" "),A("p",[_._v("上层协议类型：表示硬件地址要映射的协议地址类型，若为IP协议，其值为4")]),_._v(" "),A("p",[_._v("操作类型：指定本次ARP报文类型，例如，1表示ARP请求，2表示ARP应答")]),_._v(" "),A("p",[_._v("ARP报文并不是直接在网络层上发送的，它还是需要向下传输到数据链路层，所以当ARP报文传输到数据链路层后，需要再次进行封装。在以太网中，ARP传输到数据链路层后会封装成ARP帧。其格式如下图所示：")]),_._v(" "),A("p",[A("img",{attrs:{src:"https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E6%8A%A5%E6%96%87%E5%B0%81%E8%A3%85.png",alt:""}})]),_._v(" "),A("p",[_._v("可以看出，其帧封装都是一样的，网络层的直接作为数据链路层帧的数据部分。")]),_._v(" "),A("p",[_._v("目的MAC地址：如果是ARP请求帧，因为它是一个广播帧，所以要填上广播MAC地址——FF-FF-FF-FF，其目标为网络上的所有主机。")]),_._v(" "),A("p",[_._v("源MAC地址：发送ARP帧的节点MAC地址")]),_._v(" "),A("p",[_._v("帧类型：标识帧封装的上层协议")]),_._v(" "),A("h2",{attrs:{id:"_4、rarp协议"}},[A("a",{staticClass:"header-anchor",attrs:{href:"#_4、rarp协议","aria-hidden":"true"}},[_._v("#")]),_._v(" 4、RARP协议")]),_._v(" "),A("p",[_._v("RARP分组的格式与ARP分组基本一致。RARP为逆地址解析协议，作用与ARP相反，用于将MAC地址转换为IP地址。")]),_._v(" "),A("p",[_._v("具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址，但是无盘机，如X中断或无盘工作站，则需要采用其他方法来获得IP地址。")]),_._v(" "),A("p",[_._v("总得说来就是，网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求，请求某个主机响应该无盘系统的IP地址。")]),_._v(" "),A("p",[_._v("RARP的工作过程如下：")]),_._v(" "),A("p",[_._v("1、网络上每台设备都会有一个独一无二的硬件地址，一般是由设备厂商分配的MAC地址。发送主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求任何收到此请求的RARP服务器分配一个IP地址；")]),_._v(" "),A("p",[_._v("2、RARP服务器收到此请求后，检查其RARP表项，查找该MAC地址对应的IP地址；")]),_._v(" "),A("p",[_._v("3、如果存在，RARP服务器就给发送主机回复一个响应数据包，并将此IP地址提供给对方主机使用；")]),_._v(" "),A("p",[_._v("4、如果不存在，RARP服务器对此不做任何的响应；")]),_._v(" "),A("p",[_._v("5、发送主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯，如果一直没有收到RARP服务器的响应消息，表示初始化失败。\n与ARP不同的是RARP是主机向RARP服务器获取自己的IP地址。")])])}),[],!1,null,null,null);v.default=P.exports}}]);
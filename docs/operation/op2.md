---
title: 进程管理
---
[[toc]]

## 进程与线程
### 进程
进程是资源分配的基本单位。

进程控制块（`PCB`）描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对`PCB`的操作。

下图显示了4个程序创建了4个进程，这4个进程可以并发地执行。

![](https://raw.githubusercontent.com/Hewie8023/zhengli/master/image/操作系统/进程.png)
### 线程
线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ和浏览器是两个进程，浏览器进程里面有很多线程，例如HTTP请求线程、事件响应线程、渲染线程等，线程的并发执行使得在浏览器中点击一个新链接从而发起HTTP请求时，浏览器还可以响应用户的其他事件。

![](https://s2.ax1x.com/2019/10/31/KTYYXq.png)

### 区别
+ **Ⅰ 拥有资源**

    进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

+ **Ⅱ 调度**

    线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

+ **Ⅲ 系统开销**

    由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、`I/O` 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 `CPU` 环境的保存及新调度进程 `CPU` 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
 
+ **Ⅳ 通信方面**

    线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 `IPC`。

+ **Ⅴ 内核态用户态**

    进程的实现只能由操作系统内核来实现，而不存在用户态实现的情况。而线程可以分为内核态和用户态。

    内核态创建线程比较浪费系统空间资源，因为系统需要维护线程列表，而线程的数量要远远大于进程的数量，过多的线程创建会使系统资源耗尽而瘫痪。其次内核态实现会修改操作系统。

    使用用户态创建线程就不必太担心系统资源耗尽的问题，内核不需要知道有多少线程创建。用户创建方便。

    **缺点：**

    如果在执行过程中一个线程受阻，它将无法将控制权交出来，这样整个进程都无法推进。操作系统随即把`CPU`控制权交给另外一个进程。

    这样，一个线程受阻造成整个进程受阻，我们期望的通过线程对进程实施分身的计划就失败了。这是用户态线程致命的缺点。

## 进程状态的切换

![](https://s2.ax1x.com/2019/10/31/KTYa7T.png)

- 就绪状态（`ready`）：等待被调度
- 运行状态（`runing`）
- 阻塞状态（`waiting`）：等待资源

1. 就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；
2. 执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 
3. 阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；
4. 执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

应注意：
- 只有就绪态和运行态可以相互转换，其他都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片用完之后就转换为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU资源，缺少CPU时间会从运行态转换为就绪态。

## 进程调度算法
### 批处理系统
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

#### 先来先服务（FCFS）
非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 短作业优先（SJF）
非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业可能会被饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 最短剩余时间优先（SRTN）
最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新作业到达时，其整个运行时间与当前进程的剩余时间做比较。如果进的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

#### 时间片轮转
将所有就绪进程按 `FCFS` 的原则排成一个队列，每次调度时，把 `CPU` 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 `CPU` 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：
- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

#### 优先级调度
为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 多级反馈队列
一个进程需要执行`100`个时间片，如果采用时间片轮转调度算法，那么需要交换`100`次。

多级队列是为了这种需要执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8...进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

![](https://s2.ax1x.com/2019/10/31/KTY8pj.png)

### 实时系统
实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 进程同步
为什么要引入进程间的同步？由于操作系统中的进程是并发的，因此当协同进程对共享数据进行访问时，可能会造成数据的不一致性问题。为了保证数据的一致性，那么我们就需要一种有效地机制，这就是被我们称之为的进程同步机制。
### 临界区
对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

### 同步与互斥
- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能够进入临界区。

### 信号量
信号量是一个整型变量，可以对其进行`down`和`up`操作，也就是常见的`P`和`V`操作。
- `down`：如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0；
- `up`：对信号量执行+1操作，唤醒睡眠的进程让其完成`down`操作。

`down`和`up`操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为0或者1，那么就成为了**互斥量**（`mutex`），0表示临界区已经加锁，1表示临界区解锁。
```cpp
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```
#### 使用信号量实现生产者-消费者问题
**问题描述**：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量`mutex`来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：`empty`记录缓冲区还能放的数量，`full`记录缓冲区能取走的数量。其中，`empty`信号量是在生产者进程中使用，当`empty`不为0时，生产者才可以放入物品；`full`信号量是在消费者进程中使用，当`full`信号量不为0时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说不能先执行`down(mutex)`再执行`down(empty)`。如果这么做，那么可能出现：生产者对缓冲区加锁之后，执行`down(empty)`操作，发现`empty`为0，表明缓冲区已满，此时生产者进程睡眠，但是并没有释放缓冲区，那么此时消费者不能进入临界区，也就无法执行`up(empty)`操作，`empty`永远为0，导致死锁。
```cpp
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

### 自旋锁
自旋锁是为了保护共享资源提出的一种锁机制。

调用者申请的资源如果被占用，即自旋锁被已经被别的执行单元保持，则调用者一直循环在那里看是否该自旋锁的保持着已经释放了锁。

自旋锁是一种比较低级的保护数据结构和代码片段的原始方式，可能会引起以下两个问题;
- 死锁
- 过多地占用CPU资源

### 管程
使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了**条件变量**以及相关的操作：`wait()` 和 `signal()` 来实现同步操作。对条件变量执行 `wait()` 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。`signal()` 操作用于唤醒被阻塞的进程。

## 经典同步问题
### 读者-写者问题
允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量`count`记录在对数据进行读操作的进程数量，一个互斥量`count_mutex`用于对`count`加锁，一个互斥量`data_mutex`用于对读写的数据加锁。
```cpp
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```
### 哲学家进餐问题
![](https://s2.ax1x.com/2019/10/31/KTYycR.jpg)

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是错误示例，会造成死锁：
```cpp
semaphore chopstick[5] = {1,1,1,1,1};
#define N 5
void philosopher(int i) {
    while(TRUE) {
        think();
        //当哲学家饥饿时，总是先拿左边的筷子，再拿右边的筷子
    	take(chopstick[i]);
    	take(chopstick[(i+1)%N]);
    	// 吃饭
    	eat();
    	//当哲学家进餐完成后，总是先放下左边的筷子，再放下右边的筷子
    	put(chopstick[i]);
    	put(chopstick[(i+1)%N]);
    }
}
```
为了防止死锁的发生，可以使用以下三种策略：
+ **策略一**

    至多只允许四个哲学家同时进餐，以保证只有有一个哲学家能够进餐，最终总会释放出他所使用过的两根筷子，从而可使更多的哲学家进餐。定义信号量`count`，只允许4个哲学家同时进餐。
    ```cpp
    #define N 5
    semaphore chopstick[5]={1,1,1,1,1};
    semaphore count=4; // 设置一个count，最多有四个哲学家可以进来
    void philosopher(int i)
    {
        while(true)
        {
            think();
            down(&count); //请求进入房间进餐 当count为0时 不能允许哲学家再进来了
            take(chopstick[i]); //请求左手边的筷子
            take(chopstick[(i+1)%N]); //请求右手边的筷子
            eat();
            put(chopstick[i]); //释放左手边的筷子
            put(chopstick[(i+1)%N]); //释放右手边的筷子
            up(&count); //退出房间释放信号量
        }
    }
    ```
+ **策略二**

    可以利用 `AND` 型信号量机制实现，也可以利用信号量的保护机制实现。利用信号量的保护机制实现的思想是通过记录型信号量`mutex`对取左侧和右侧筷子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现。描述如下：
    ```cpp
    #define N 5
    semaphore chopstick[5]={1,1,1,1,1};
    semaphore mutex = 1; // 这个过程需要判断两根筷子是否可用，并保护起来
    void philosopher(int i)
    {
        while(true)
        {
            // 这个过程中可能只能由一个人在吃饭 
            think();
            down(&mutex);  // 保护信号量
            take(chopstick[(i+1)%N]); //请求右手边的筷子
            take(chopstick[i]); //请求左手边的筷子
            up(&mutex); //释放保护信号量
            eat();
            put(chopstick[(i+1)%N]); //释放右手边的筷子
            put(chopstick[i]); //释放左手边的筷子
        }
    }
    ```
+ **策略三**

    规定**奇数号**的哲学家先拿起他**左边**的筷子，然后再去拿他**右边**的筷子；而**偶数号**的哲学家则先拿起他**右边**的筷子，然后再去拿他**左边**的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。
    ```cpp
    #define N 5
    semaphore chopstick[5]={1,1,1,1,1};
    void philosopher(int i)
    {
        while(true)
        {
            think();
            if(i%2 == 0) //偶数哲学家，先右后左。
            {
                take (chopstick[(i + 1)%N]) ;
                take (chopstick[i]) ;
                eat();
                put (chopstick[(i + 1)%N]) ;
                put (chopstick[i]) ;
            }
            else //奇数哲学家，先左后右。
            {
                take (chopstick[i]) ;
                take (chopstick[(i + 1)%N]) ;
                eat();
                put (chopstick[i]) ;
                put (chopstick[(i + 1)%N]) ;
            }
        }
    }
    ```

## 进程通信
进程同步与进程通信很容易混淆，它们的区别在于：
- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 管道
管道是通过调用 `pipe` 函数创建的，`fd[0]` 用于读，`fd[1]` 用于写。
```cpp
#include <unistd.h>
int pipe(int fd[2]);
```
它具有以下限制：
- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

![](https://s2.ax1x.com/2019/10/31/KTYJcn.png)

### FIFO
也称为命名管道，在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。

`FIFO` 常用于客户-服务器应用程序中，`FIFO` 用作汇聚点，在客户进程和服务器进程之间传递数据。

![](https://s2.ax1x.com/2019/10/31/KTYr9J.png)

### 消息队列
消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列`ID`）来标识。

- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
- 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
- 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

### 信号量
它是一个计数器，用于为多个进程提供对共享数据对象的访问。

### 共享存储
允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 套接字
与其它通信机制不同的是，它可用于不同机器间的进程通信。
---
title: 死锁
---
[[toc]]

## 必要条件
::: tip 死锁
是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。
:::

::: tip 互斥
某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
:::
::: tip 占有和等待
一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
:::
::: tip 不可抢占
已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
:::
::: tip 环路等待
有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。
:::

## 处理方法
1. 鸵鸟策略
2. 死锁检测与死锁恢复
3. 死锁预防
4. 死锁避免

## 鸵鸟策略
把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 `Unix`，`Linux` 和 `Windows`，处理死锁问题的办法仅仅是忽略它。

## 死锁检测与死锁恢复
允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。

主要有两种死锁检测方法：超时机制和检测是否存在环路。

在检测到发生死锁之后，可以使用进程回退或者事务回滚等机制，释放获取的资源，之后再重新执行。

`InnoDB` 存储引擎使用检测是否存在环路的方式，并且选择将回滚操作代价小的事务进行回滚。

## 死锁预防
死锁预防是在程序运行之前通过某些手段从而保证不发生死锁。

### 破坏互斥条件
临界资源需要互斥访问，所以基本不能破坏互斥条件。但也可以使用一些手段来使得多个进程可以用共享的方式去使用临界资源。例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

### 破坏占有和等待条件
+ **方法1**

    所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。
    - 优点：简单易实施且安全。
    - 缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。使进程经常发生饥饿现象。

+ **方法2**

    该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。

### 破坏不可抢占条件
当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。
      
该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。

### 破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。

但有些资源本身并不具有编号属性，如果加上编号的话，那么会让程序逻辑变得复杂。

## 死锁避免
在使用前进行判断，只允许不会产生死锁的进程申请资源。

死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。
两种避免办法：
1. 如果一个进程的请求会导致死锁，则不启动该进程
2. 如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。

### 银行家算法
银行家算法是从当前状态出发，按照系统各类资源剩余量逐个检查各进程需要申请的资源量，找到一个各类资源申请量均小于等于系统剩余资源量的进程P1。然后分配给该P1进程所请求的资源，假定P1完成工作后归还其占有的所有资源，更新系统剩余资源状态并且移除进程列表中的P1，进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。若找不到这样的安全序列，则当前状态不安全。
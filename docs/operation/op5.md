---
title: 内存管理
---
[[toc]]

## 虚拟内存
虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 `16` 位地址，那么一个程序的地址空间范围是 `0~64K`。该计算机只有 `32KB` 的物理内存，虚拟内存技术允许该计算机运行一个 `64K` 大小的程序。


## 分页系统地址映射
内存管理单元（`MMU`）管理着地址空间和物理内存的转换，其中的页表（`Page table`）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 `16` 个页，这 `16` 个页需要用 `4` 个比特位来进行索引定位。例如对于虚拟地址（`0010 000000000100`），前 `4` 位是存储页面号 `2`，读取表项内容为（`110 1`），页表项最后一位表示是否存在于内存中，`1` 表示存在。后 `12` 位存储偏移量。这个页对应的页框的地址为 （`110 000000000100`）。

![](https://s2.ax1x.com/2019/10/31/KTYG1s.png)

## 页面置换算法
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 最佳
所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

### 最近最久未使用（LRU）
为了实现 `LRU`，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

`LRU`算法的描述： 设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：
- `set(key,value)`：将记录`(key,value)`插入该结构。当缓存满时，将最久未使用的数据置换掉。
- `get(key)`：返回`key`对应的`value`值。

实现：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（`LinkedList`）+哈希表（`HashMap`）实现（链表用来表示位置，哈希表用来存储和查找）

### 先进先出
选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

### 最近最少使用（LFU）
如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。

设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：
- `set(key,value)`：将记录`(key,value)`插入该结构。当缓存满时，将访问频率最低的数据置换掉。
- `get(key)`：返回`key`对应的`value`值。

算法实现策略：考虑到 `LFU` 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。`LFU` 算法本质上可以看做是一个 `top K` 问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为**小顶堆+哈希表**。

## 分段
虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

![](https://s2.ax1x.com/2019/10/31/KTYK78.png)

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

![](https://s2.ax1x.com/2019/10/31/KTYQAS.png)

### 段页式
程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

### 分页与分段的比较
对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

地址空间的维度：分页是一维地址空间，分段是二维的。

大小是否可以改变：页的大小不可变，段的大小可以动态改变。

出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
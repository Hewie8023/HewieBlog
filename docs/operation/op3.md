---
title: 线程管理
---

[[toc]]

## 线程基本概念
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

+ **线程共享资源**
    1. 进程代码段 
    2. 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 
    3. 进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

+ **线程独立资源包括**
    1. **线程ID**

        每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。
    2. **寄存器组的值**
        
        由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
    3. **线程的堆栈**
        
        堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。
    4. **错误返回码**
        
        由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。
    5. **线程的信号屏蔽码**
        
        由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。
    6. **线程的优先级**
        
        由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

## 线程调度策略
`linux`内核的三种调度方法：
- `SCHED_OTHER` 分时调度策略。注意的是这排队跟上`WC`一样，前面的人占用了位置，它不出来，第二个人是轮不上的。
- `SCHED_FIFO`实时调度策略，先到先服务。一旦占用`cpu`则一直运行，直到有更高优先级任务到达或自己放弃。
- `SCHED_RR`实时调度策略，时间片轮转。当任务的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾保证了所有具有相同优先级的`RR`任务的调度公平。

## 线程同步
### 互斥锁
互斥锁机制是同一时刻只允许一个线程执行一个关键部分的代码。

### 条件变量
条件变量是利用线程间共享全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 `true` 时)；等待条件，挂起线程直到其他线程触发条件。

### 信号量
如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。

### 读写锁
读写锁和互斥量类似，区别在于：互斥量只有两个状态，即锁住状态和不加锁状态，而且一次只有一个线程可以对其加锁。而读写锁可以有三个状态，读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只能有一个线程占有写模式的读写锁，但可以由多个线程同时占有读模式的读写锁。

读写锁非常适用于对数据结构读次数远大于写的情况。

## 线程通信
### 全局变量
由于属于同一个进程的各个线程共享操作系统分配该进程的资源，故解决线程间通信最简单的一种方法是使用全局变量。对于标准类型的全局变量，我们建议使用 `volatile` 修饰符，它告诉编译器无需对该变量作任何的优化，即无需将它放到一个寄存器中，并且该值可被外部改变。如果线程间所需传递的信息较复杂，我们可以定义一个结构，通过传递指向该结构的指针进行传递信息。

### 自定义消息
我们可以在一个线程的执行函数中向另一个线程发送自定义的消息来达到通信的目的。一个线程向另外一个线程发送消息是通过操作系统实现的。利用`Windows`操作系统的消息驱动机制，当一个线程发出一条消息时，操作系统首先接收到该消息，然后把该消息转发给目标线程，接收消息的线程必须已经建立了消息循环。

### std::promise和std::future
`std::promise` 可以用来在线程间提供数据传递。

`std::future = std::promise.get_future()`。

线程中可以对`promise`赋值:`std::promise.set_value`。

赋值之后`std::future.get()`就会返回其他线程中设置的值

### std::packaged_task 
可以包裹一个函数, 有点类似`std::function`，不同之处在于这个可以通过`get_future`返回`std::future`对象来获取异步执行的函数结果。

### std::async
`std::async`提供异步执行的方法，`std::future = std::async(...)`, 函数执行完成后可以通过`std::future.get()`获取到执行函数的返回值。

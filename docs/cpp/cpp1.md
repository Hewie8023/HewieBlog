---
title: C++基础
---
:point_down:内容速览:point_down:
[[toc]]

## 基本语言篇

## 编译与底层篇

### C++源文件从文本到可执行文件的过程<Badge text="未完成" type="error"/>


### include头文件的顺序以及双引号""和尖括号的区别<Badge text="未完成" type="error"/>


### 共享内存相关api<Badge text="未完成" type="error"/>


### C++内存模型
![]()
**堆 heap** ：
+ 用来存放进程运行中被动态分配的内存段。由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

**栈 stack** ：
+ 是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
    存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
    存放程序中的局部变量（但不包括static声明的变量，static变量放在数据段中）。同时，在函数被调用时，栈用来传递参数和返回值。由于栈先进先出特点。所以栈特别方便用来保存/恢复调用现场。

**全局/静态存储区 （.bss段和.data段）** ：
+ 全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

**常量存储区 （.rodata段）** ：
+ 存放常量，不允许修改（通过非正当手段也可以修改）

**代码区 （.text段）** ：
+ 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

### malloc的内存分配方式，另外brk系统调用和mmap系统调用的作用分别是什么？<Badge text="未完成" type="error"/>

`malloc`基本的实现原理就是**维护一个内存空闲链表**，当申请内存空间时，搜索内存空闲链表，找到适配的空闲内存空间，然后将空间分割成两个内存块，一个变成分配块，一个变成新的空闲块。如果没有搜索到，那么就会用`sbrk()`才推进`brk`指针来申请内存空间。

搜索空闲块最常见的算法有：首次适配，下一次适配，最佳适配。

**首次适配**：第一次找到足够大的内存块就分配，这种方法会产生很多的内存碎片。

**下一次适配**：也就是说等第二次找到足够大的内存块就分配，这样会产生比较少的内存碎片。

**最佳适配**：对堆进行彻底的搜索，从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块。

**合并空闲块**
在释放内存块后，如果不进行合并，那么相邻的空闲内存块还是相当于两个内存块，会形成一种假碎片。所以当释放内存后，我们需要将两个相邻的内存块进行合并。

### new和malloc的区别

**1. 返回类型安全性**

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void指针转换成我们需要的类型。

**2. 内存分配失败时的返回值**

new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL*；malloc分配内存失败时返回NULL。

**3. 是否需要指定内存大小**

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

**4.属性**

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要c头文件支持。

**5.** new 建立的是一个对象,malloc分配的是一块内存。

### free之后的指针使用有什么问题
`free(str)`后指针仍然指向原来的堆地址，即你仍然可以继续使用，但很危险，因为操作系统已经认为这块内存可以使用，他会毫不考虑的将他分配给其他程序，于是你下次使用的时候可能就已经被别的程序改掉了，这种情况就叫“野指针”，所以最好`free()`了以后再置空
`str = NULL;`
即本程序已经放弃再使用他。

### 如果物理内存是2G 如果mallco 4G可以么？会有什么问题？
malloc的实现与物理内存自然是无关的，分配到的内存只是虚拟内存，而且只是虚拟内存的页号，代表这块空间进程可以用，实际上还没有分配到实际的物理页面。

### new具体是怎么开辟内存的
> 简单数据类型（包括基本数据类型和不需要构造函数的类型）

+ 简单类型直接调用`operator new`分配内存；
+ 可以通过`new_handler`来处理`new`失败的情况；
+ `new`分配失败的时候不像`malloc`那样返回`NULL`，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；
> 复杂数据类型（需要由构造函数初始化对象）

+ `new`复杂数据类型的时候先调用`operator new`，然后在分配的内存上调用构造函数。

### C/C++内存问题有哪些
+ 内存重复释放（一般在出现double free时基本上都是这个原因）
+ 内存泄漏。申请的内存忘了释放。
+ 内存越界使用
+ 内存未分配成功确使用了它
+ 内存分配成功却没有初始化就使用了内存
+ 使用了无效指针
    + 已经释放对象，却继续操作改指针所指的对象
        - 程序当中的对象调用关系过于复杂，是在难以搞清哪个对象是否已经释放了内存，从根本上解决对象管理混乱的情况。
        - 函数的`return`语句写错了，注意不要返回指向“栈内存”的指针或者引用。`char * getString(){char b[] = "Hello, Tocy!"; return b;}`
        - 使用`free`或者`delete`释放之后，没有将其置空，导致产生野指针。
    + 多线程中某一动态分配的对象同时被两个线程使用，一个线程释放了该对象，另一个线程却继续对该对象进行操作

### 什么时候会发生段错误<Badge text="未完成" type="error"/>


### 内存泄漏和内存溢出的区别？
+ **内存溢出**

系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出。

比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。

+ **内存泄漏**

用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出。

向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

### 定位内存泄露
**1. 查看进程maps表**

在实际调试过程中，怀疑某处发生了内存泄漏，可以查看该进程的maps表，看进程的堆或mmap段的虚拟地址空间是否持续增加。如果是，说明可能发生了内存泄漏。如果mmap段虚拟地址空间持续增加，还可以看到各个段的虚拟地址空间的大小，从而可以确定是申请了多大的内存。

**2. 重载new/delete操作符**

重载new/delete操作符，用list或者map记录对内存的使用情况。new一次，保存一个节点，delete一次，就删除节点。
最后检测容器里是否还有节点，如果有节点就是有泄漏。也可以记录下哪一行代码分配的内存被泄漏。
类似的方法：在每次调用new时加个打印，每次调用delete时也加个打印。

**3. top 指令**

 在Linux上面可以快速定位泄漏的程序和程度。

**4. matrace**

mtrace的原理是记录每一对malloc-free的执行，若每一个malloc都有相应的free，则代表没有内存泄露；
对于任何非malloc/free情況下所发生的内存泄露问题，mtrace并不能找出来。

### 栈溢出和堆溢出的区别？
+ 堆溢出：不断的new 一个对象，一直创建新的对象，但是没有delete
+ 栈溢出：死循环或者是递归太深，递归的原因，可能太大，也可能没有终止。

### 堆和栈的区别(从数据结构和内存方面)
#### 数据结构中的堆和栈

**栈**就像装数据的桶或箱子，是一种具有后进先出性质的数据结构。

**堆**像是一颗倒立的大树，堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。

#### 内存中的堆和栈

> **堆栈空间分配**
> 
> 栈：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
>
> 堆： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

>**堆栈缓存方式**
>
>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
>
>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

![]()

```cpp
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() 
{ 
    int b; 栈 
    char s[] = "abc"; 栈 
    char *p2; 栈 
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。 
    static int c =0； 全局（静态）初始化区 
    p1 = (char *)malloc(10);  堆 
    p2 = (char *)malloc(20);  堆 
}
```

> 区别 :point_down:

**1. 申请方式和回收方式不同**

栈（satck）:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间。
堆（heap）:需程序员自己申请（调用`malloc,realloc,calloc`）,并指明大小，并由程序员进行释放。容易产生memory leak。
```cpp
char  *p;
p = (char *)malloc(sizeof(char));
```
但是，p本身是在栈中。

由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。

**2. 申请后系统的响应**

1）栈：只要栈的空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

2）堆：首先应该知道操作系统有一个记录空闲内存地址的链表，但系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的free语句才能正确的释放本内存空间。另外，找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

说明：对于堆来讲，频繁的`new/delete`势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题
堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。

**3. 申请效率**

栈由系统自动分配，速度快。但程序员是无法控制。

堆是由malloc分配的内存，一般速度比较慢，而且容易产生碎片，不过用起来最方便。

**4. 申请大小的限制**

1）栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示`overflow`。因此，能从栈获得的空间较小。

2）堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

**5. 堆和栈中的存储内容**

1）栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

2）堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

**6. 存取效率**

堆：`char *s1="hellow tigerjibo"`;是在编译是就确定的；

栈：`char s1[]="hellow tigerjibo"`;是在运行时赋值的；用数组比用指针速度更快一些，指针在底层汇编中需要用`edx`寄存器中转一下，而数组在栈上读取。

**7. 分配方式**

堆都是动态分配的，没有静态分配的堆。

栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的。它的动态分配是由编译器进行释放，无需手工实现。

### 如何限制一个类对象只在栈（堆）上分配空间？
在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。

**静态建立类对象：**
是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。

**动态建立类对象：**
是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

#### 只能在堆上分配类对象<Badge text="堆" type="warn"/>

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

因此，**将析构函数设为私有**，类对象就无法建立在栈上了。

```cpp
class A  
{  
public:  
    A(){}  
    void destory(){delete this;}  
private:  
    ~A(){}  
};  
```

试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。

**上述方法的缺点：**

> 无法解决继承问题

如果A作为其它类的基类，则析构函数通常要设为`virtual`，然后在子类重写，以实现多态。
因此析构函数不能设为`private`。
还好`C++`提供了第三种访问控制，`protected`。
将析构函数设为`protected`可以有效解决这个问题，类外无法访问`protected`成员，子类则可以访问。

> 类的使用很不方便

使用`new`建立对象，却使用`destory()`函数释放对象，而不是使用`delete()`。
(使用`delete()`会报错，因为`delete()`对象的指针，会调用对象的析构函数，而析构函数类外不可访问。这种使用方式比较怪异。)

为了统一，可以将构造函数设为`protected`，然后提供一个`public`的static函数来完成构造，这样不使用`new`，而是使用一个函数来构造，使用一个函数来析构。

```cpp
class A  
{  
protected:  
    A(){}  
    ~A(){}  
public:  
    static A* create()  
    {  
        return new A();  
    }  
    void destory()  
    {  
        delete this;  
    }  
}; 
```

这样，调用`create()`函数在堆上创建类A对象，调用`destory()`函数释放内存。

#### 只能在栈上分配类对象<Badge text="栈" type="warn"/>

只有使用`new`运算符，对象才会建立在堆上，因此，只要禁用`new`运算符就可以实现类对象只能建立在栈上。
虽然你不能影响`new operator`的能力（因为那是`C++`语言内建的），但是你可以利用一个事实：`new operator` 总是先调用 `operator new`，而后者我们是可以自行声明重写的。

因此，将`operator new()`设为私有即可禁止对象被`new`在堆上。

```cpp
class A  
{  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};  
```

### 对内存对齐的理解，为什么要内存对齐
CPU每次从内存中取出数据或者指令时，并非想象中的一个一个字节取出拼接的，而是根据自己的字长，也就是CPU一次能够处理的数据长度取出内存块，比如32位处理器将取出32位也就是4个字节的内存块进行处理。这里有一个问题：是只需要两个字节怎么办？答案是还是取出4个字节，然后内存处理器会帮忙完成数据挑拣在传送给CPU。

1. **平台原因**(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. **性能原因**：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

内存对齐又分为**自然对齐**和**规则对齐**。

**自然对齐**指的是将对应变量类型存入对应地址值的内存空间，即数据要根据其数据类型存放到以其数据类型为倍数的地址处。例如`char`类型占1个字节空间，1的倍数是所有数，因此可以放置在任何允许地址处，而int类型占4个字节空间，以4为倍数的地址就有0,4,8等。编译器会优先按照自然对齐进行数据地址分配。

**规则对齐**以结构体为例就是在自然对齐后，编译器将对自然对齐产生的空隙内存填充无效数据，且填充后结构体占内存空间为结构体内占内存空间最大的数据类型成员变量的整数倍。

### 设计一下如何采用单线程的方式处理高并发<Badge text="未完成" type="error"/>



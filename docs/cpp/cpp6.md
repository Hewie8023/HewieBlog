---
title: 浅析STL
---

[[toc]]

## 概述
`STL`有容器，空间配置器，适配器，迭代器，仿函数以及算法这6个组件，它们六者关系大概如下：容器通过配置器取得数据存储空间,算法通过迭代器获取容器内容,仿函数可以协助算法完成不同的策略变化,适配器是通过组合特定的容器实现的一种新的数据结构。

## 迭代器
`STL`将数据和算法分开。 数据存储在容器里，使用算法进行操作。迭代器是这两者之间的粘合剂，让算法与容器可以进行交互。

`Iterator`（迭代器）模式又称`Cursor`（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。或者这样说可能更容易理解：`Iterator`模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由`iterator`提供的方法）访问聚合对象中的各个元素。
 
由于`Iterator`模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如`STL`的`list`、`vector`、`stack`等容器类及`ostream_iterator`等扩展`iterator`。

### 设计迭代器的原因
1. 通过迭代器访问容器，可以避免许多错误，同时还能隐藏容器的具体实现。
2. 迭代器可以保证对所有容器的基本遍历方式，都是一样的，实现算法时若需要遍历，则使用迭代器，则可以不用关注容器的具体类型，实现数据结构和算法的分离。
3. 迭代器本身有很多优点，可以弥补`C++`语言的不足，比如它的`iterator_category`，可以得到迭代器所指向的类别，这样可以根据不同的类别的特性，提供不同的算法。
### 迭代器和指针的区别
迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，`->`、`\*`、`++`、`--`等。迭代器封装了指针，是一个“可遍历`STL`（ `Standard Template Library`）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升（`lift`），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的`++`，`--`等操作。迭代器返回的是对象引用而不是对象的值，所以`cout`只能输出迭代器使用*取值后的值而不能直接输出其自身。

### 迭代器的分类
`STL`中的迭代器可分为：随机存取迭代器（`random-access-iterator`），双向存取迭代器(`bidirectional-access-iterator`)，前向迭代器(`forward iterator`)，输入迭代器(`input-iterator`)，输出迭代器(`output-iterator`)。它们之间的继承关系如下：
```cpp
input-iterator
output-iteartor    
forward-iterator:output-iteartor , input-iterator
bidirectional-access-iterator : forward-iterator
random-access-iterator:bidirectional-access-iterator
```

#### 输入迭代器
输入迭代器也可以称之为前向的只读访问器，首先它提供了对容器的只读访问，其次它只能在容器中进行前向迭代（即只提供`++`操作）。所有的容器的迭代器都具有输入迭代器的特征。通过输入迭代器你可以进行下面三种操作：
```cpp
1. V = *X++
2. V = *X,X++
3. V = *X,++X
注：`V`为值，`X`为迭代器
```

`*p ` 复引用迭代器，作为右值
```cpp
p=p1    将一个迭代器赋给另一个迭代器
p==p1   比较迭代器的相等性
p!=p1   比较迭代器的不等性
```

#### 输出迭代器
输出迭代器也可以称之为前向的只写访问器，首先它提供了对容器的只写访问，其次它只能在容器中进行前向迭代（即只提供`++`操作）。通过输出迭代器你可以进行下面三种操作：
```cpp
1. *X++ = V
2. *X = V, X++
3. *X = V, ++X
注：V为值，X为迭代器
```

#### 前向迭代器
前向迭代器继承自输入和输出迭代器，因此具有输入和输出迭代器的所有特征，也即提供对容器数据结构的读写访问但也只具有前向迭代的能力（即只提供`++`操作）。因此，你可以对前向迭代器进行操作：`R == S /++R == ++S`。

#### 双向迭代器
双向存取迭代器从前向迭代器继承过来，因而具有前向迭代器的所有特征，双向存取迭代器还具有后向访问能力（即只提供`--`操作）。

#### 随机迭代器
随机存取迭代器从双向存取迭代器继承过来，因而具有双向存取迭代器的所有特征。所不同的是，利用随机存取迭代器你可以对容器数据结构进行随机访问。
```cpp
p+=i    将迭代器递增i位
p-=i    将迭代器递减i位
p+i     在p位加i位后的迭代器
p-i     在p位减i位后的迭代器
p[i]    返回p位元素偏离i位的元素引用
p<p1    如果迭代器p的位置在p1前，返回true，否则返回false
p<=p1   p的位置在p1的前面或同一位置时返回true，否则返回false
p>p1    如果迭代器p的位置在p1后，返回true，否则返回false
p>=p1   p的位置在p1的后面或同一位置时返回true，否则返回false
```
## 容器
`STL`中的容器可分为顺序容器(`Sequence Container`)和关联容器(`Associative Container`)。

顺序容器：`vector`、`deque`、`list`、`stack`、`queue`、`priority_queue`（后三个为非`STL`标准）

关联容器：`set`、`multiset`、`map`、`multimap`（底层都是红黑树）、`hashtable`、`hash_set`、`hash_map`、`hash_multiset`、`hash_multimap`（后五个为非`STL`标准，后四个底层为`hashtable`）

### 共性
所有的容器都是物之所在，这就决定了它们必然存在很多共性，这些共性包括迭代器、大小等属性。容器与容器之间的主要区别体现在对数据的操作上。

每类容器都包含四个迭代器：`iterator`(正向迭代器)、`const_iterator`(常正向迭代器)、`reverse_iterator`(反向迭代器)、`const_reverse_iterator`(常反向迭代器)。
因此你可以按照下面的方式获取每个容器的相应的迭代器：
+ 获取正向迭代器
    ```cpp
    C<T>::iterator it = c.begin();
    C <T>::iterator it = c.end();
    ```
+ 获取反向迭代器
    ```cpp
    C <T>::reverse_iterator it = c.rbegin();
    C <T>:: reverse_iterator it = c.rend()
    ```
+ 获取常正向迭代器
    ```cpp
    C<T>::const_iterator it = c.begin();
    C <T>:: const_iterator it = c.end();
    ```
+ 获取常反向迭代器
    ```cpp
    C <T>:: const_ reverse_iterator it = c.rbegin();
    C <T>:: const_ reverse_iterator it = c.rend()
    ```
    注：`C`为容器类型，`c`为`C`的实例

所有容器是数据的存在之处，可以看作的是数据的集合，因此它们都会有大小、是否为空等属性，因此你可以按照下面的方式获取所有的容器的公共属性：
+ 获取容器的大小
    `c.size()`
+ 判断容器是否为空
    `c.empty()`

### 顺序容器
顺序容器中所有的元素在容器中的物理位置都是按照特定的次序进行存放的，区别于关联容器的是顺序容器中的元素的位置都是既定的。被纳入`STL`标准的顺序容器包括`vector`、`list`、`deque`。

序列容器之间的共性除了容器之间应有的共性之外，还有对数据操作的接口(非实现)上：
```cpp
c.push_back
c.pop_back
c.push_front
c.pop_front
c.back
c.front
c.erase
c.remove
```

#### vector
`vector`和数组具有同样的内存处理方式。不同于数组的是：数组是静态空间，一旦分配了就不能被改变，因而空间的分配非常地不灵活；`vector`是动态空间，即空间可以被动态分配，因而空间的分配很灵活。

`vector`中的迭代器的种类为随机存取迭代器。

##### vector的底层实现
简单理解，就是`vector`是利用三个指针来表示的，基本示意图如下：

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/vector.png) 

两个关键大小： 
+ 大小：`size = _Mylast - _Myfirst `
+ 容量：`capacity = _Myend - _Myfirst`

分别对应于`resize()`、`reserve()`两个函数。 

`size`表示`vector`中已有元素的个数，容量表示`vector`最多可存储的元素的个数；为了降低二次分配时的成本，`vector`实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即`capacity >= size`，当等于时，容器此时已满，若再要加入新的元素时，就要重新进行内存分配，整个`vector`的数据都要移动到新内存,释放之前的内存，再插入新增的元素。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。

##### vector可以存放任意类型的数据结构吗
`vector`可以存放自定义的结构体，方法有：放入这个结构体类型变量的副本或者放入指向这个结构体类型变量的指针。

##### vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因
在一个`vector`的尾部之外的任何位置添加元素，都需要重新移动元素。而且，向一个`vector`添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间

#### list
`list`由双向链表（`doubly linked list`）实现而成，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供`[]`操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的插入和删除操作。相对`vector`，`list`没有`capaciy`属性。

`list`中的迭代器的种类为双向存取迭代器。

#### deque
`deque`，即双向链表。相对`vector`，`deque`也是连续空间，但不是`vector`的连续线性空间。它允许较为快速地随机访问但它不像`vector`一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。

`deque`中的迭代器的种类为随机存取迭代器。

##### deque的实现原理
`deque`是由一段一段的定量连续空间构成。一旦有必要在`deque`的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个`deque`的头端或尾端。`deque`的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。

受到分段连续线性空间的字面影响，我们可能以为`deque`的实现复杂度和`vector`相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。`deque`的实现代码分量远比`vector`或`list`都多得多。

`deque`采用一块所谓的`map`（注意，不是`STL`的`map`容器）作为主控。这里所谓`map`是一小块连续空间，其中每个元素（此处称为一个节点，`node`）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是`deque`的储存空间主体。`SGI STL` 允许我们指定缓冲区大小，默认值`0`表示将使用`512 bytes` 缓冲区。
`deque`的整体架构如下图所示：

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/deque01.png)


让我们思考一下，`deque`的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，`deque`必须随时掌握管控中心（`map`）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向`map`中指向所在缓区地址的指针，分别为`cur`, `first`, `last`, `node`。
指针结构如下图所示：

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/deque02.png)

#### stack、queue、priority_queue
`stack`(栈)是一种后进先出的数据结构，也就是`LIFO`(`last in first out`) ，最后加入栈的元素将最先被取出来，在栈的同一端进行数据的插入与取出，这一段叫做“栈顶”。
```cpp
template <class T, class Container = deque<T> > class stack
```
如上，这对尖括号中有两个参数:
+ 第一个是`T`，表示栈中存放的数据的类型，比如`int`，`double`，或者结构体之类。
+ 第二个参数指明底层实现的容器类型，也就是指明这个栈的内部实现方式，比如`vector`，`deque`，`list`。如果不指明它，默认使用`deque`(双端队列)。当然一般情况下不需要指定这一项参数。

`queue`与`stack`模版非常类似，`queue`模版也需要定义两个模版参数：一个是元素类型，一个是容器类型。元素类型是必要的，容器类型是可选的，默认为`dqueue`类型。

`priority_queue`模版类有三个模版参数：元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为`vector`，默认算子为`less`，即小的往前排，大的往后排（出队时序列尾的元素出队）。

### 关联容器
关联容器(`Associative Container`)提供了根据`key`快速检索数据的能力。在关联容器(`Associative Container`)中，`key`和元素都是成对(`pair`)存在的,你可以调用`std::make_pair`使用`key`和元素值来构建一个`pair`。

`STL`提供的关联容器包括`set`、`multiset`、`map`、`multimap`。

`set`和`map`只支持唯一键(`unique key`)，即对个`key`最多只保存一个元素。`multiset`和`multimap`则支持多个`key`，一个`key`可以对应多个元素。

`set`和`map`的区别在于，在`set`里面`key`和元素是同一个值，而在`map`里面`key`和元素分开存储。

#### set
`set`是集合的抽象数据结构(`ADT`)。不同于数学意义上的集合，`STL`中的`set`的所有的元素都是有序的而且`set`中所有的元素都是唯一的，而且系统能根据元素的值自动进行排序。底层采用**红黑树**来实现。

`set`中的迭代器的种类为双向存取迭代器。

#### multiset
`multiset`和`set`基本相同，所不同的是，一个`multiset`中的元素是可以重复的。

`multiset`中的迭代器的种类为双向存取迭代器。

#### map
`map`是字典的抽象数据结构(`ADT`)。`map`中的所有的元素都会根据`key`自动进行排序，而且所有的元素都是唯一的。`map`中的所有的元素都是`pair`，即键(`key`)和值(`value`)组成的序列(`pair`中的第一个元素为`key`，第二个元素为`value`)。

底层使用**红黑树**来实现。插入: `O(logN)`，查看:`O(logN)`，删除:`O(logN)`

`map`中的迭代器的种类为双向存取迭代器。

##### map用find和[]的区别
最大的区别是当待查找的 `key` 不存在时：
1. `map::find` 返回一个空迭代器（`map::end`）。
2. `map::operator[]` 将用 `value` 默认的构造函数创建一个对象并插入到 `map` 中，将其返回。

#### multimap
`multimap`和`map`基本相同，所不同的是，一个`multimap`中的`key`可以重复。

`multimap`中的迭代器的种类为双向存取迭代器。

#### hashtable
其基本原理是：使用一个下标范围比较大的数组来存储元素。把关键字`key`通过一个固定的算法函数即所谓的哈希函数（散列函数）转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将`value`存储在以该数字为下标的`list`空间里。也可以简单的理解为，按照关键字`key`为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。

为了避免哈希表太大，需要用到某种映射函数，将大数映射为小数，这种函数称为散列函数`hash function`。但`hash function`会带来碰撞问题，即不同的元素被映射到相同位置。

为了解决碰撞问题有三种方法：线性探测、二次探测、开链。

`hashtable`就是用的开链法。

#### hash_map
`hash_map`基于哈希表，哈希表的最大优点就是把数据的存储和查询消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。

`hash_map`，首先分配一大块内存，形成许多桶，利用`hash`函数，对`key`进行映射到不同区域（桶）进行保存。其插入过程是：
1. 得到`key`
2. 通过`hash`函数得到`hash`值
3. 得到桶号（一般都为`hash`值对桶数求模）
4. 存放`key`与`value`在桶内。 

其取值过程是：
1. 得到`key`
2. 通过`hash`函数得到`hash`值
3. 得到桶号
4. 比较桶的内部元素是否与`key`相等，若不想等，则没有找到
5. 取出相等记录的`value`。

##### 什么时候需要用hash_map，什么时候需要用map?
总体来说，`hash_map`查找速度会比`map`快，而且查找速度基本和数据量大小相关，属于常数级别；而`map`的查找速度是`log(n)`级别。并不一定常数就比`log(n)`小，`hash`还有`hash`函数的耗时。如果你考虑效率，特别是元素达到一个数量级时，考虑考虑`hash_map`。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心。

选择基于三个因素：查找速度，数据量，内存使用。


#### hash_set
`hash_set`是以哈希表（`Hash table`）作为底层数据结构的。

#### unordered_map
类似于`hash_map`，但是`hash_map`不是标准库的

### 自动扩容
#### vector扩容原理
1. 新增元素：`vector`通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
2. 对`vector`的任何操作，一旦引起空间重新配置，指向原`vector`的所有迭代器就都失效了 ；
3. 初始时刻`vector`的`capacity`为`0`，塞入第一个元素后`capacity`增加为`1`；
4. 不同的编译器实现的扩容方式不一样，`VS2015`中以`1.5`倍扩容，`GCC`以`2`倍扩容。

**为什么：**

1. `vector`在`push_back`以成倍增长可以在均摊后达到`O(1)`的事件复杂度，相对于增长指定大小的`O(n)`时间复杂度更好。
2. 为了防止申请内存的浪费，现在使用较多的有`2`倍与`1.5`倍的增长方式，而`1.5`倍的增长方式可以更好的实现对内存的重复利用，因为更好。

#### hash_map扩容
扩容时需要满足两个条件：存放新值的时候当前`hash_map`所有元素的个数大于等于阈值；存放新值的时候当前存放数据发生`hash`碰撞。

`STL`会默认指定初始桶大小为`16`，负载因子是`0.75`，因此阈值就是`16\*0.75 = 12`，所以当新插入元素时，当前的元素个数超过`12`，并且发生了冲突，就会扩容`hash`桶。扩容的大小是给之前的数组翻倍。

在`hashmap`数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是`resize`。 所以如果已经预知`hashmap`中元素的个数，那么预设元素的个数能够有效的提高`hashmap`的性能，例如最多有`1000`个元素，则创建时：`new HashMap(2048)`（`1024`是不够的，要考虑负载因子：`1024*0.75 = 768`）。

另外桶的大小为`2`的幂次方时，`hash_map`的效率最高。这是因为：正常的取`index`方法为`hash%length`，但是由于位运算比取余快，所以代码中实现为`index = hash & (length - 1)`，所以只有`length`大小为`2`的次幂时：`hash % length == hash & (length - 1)`。

#### deque自动扩容
`deque`由一段一段构成 ,他是分段连续,而不是内存连续 当走向段的尾端时候自动跳到下一段 所以支持迭代器 `++` 操作,自动跳到下一段的方法由`operator++`实现。`deque`每次扩充申请一个段。

### 迭代器失效
1. 对于序列式容器(如`vector`,`deque`)，序列式容器就是数组式容器，删除当前的`iterator`会使后面所有元素的`iterator`都失效。这是因为`vetor`,`deque`使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用`erase(iter++)`的方式，还好`erase`方法可以返回下一个有效的`iterator`。

```cpp
for (iter = cont.begin(); iter != cont.end();)
{
   (*it)->doSomething();
   if (shouldDelete(*iter))
      iter = cont.erase(iter);  //erase删除元素，返回下一个迭代器
   else
      ++iter;
}
```
对于序列式容器，比如`vector`，删除当前的`iterator`会使后面所有元素的`iterator`都失效。这是因为顺序容器内存是连续分配（分配一个数组作为内存），删除一个元素导致后面所有的元素会向前移动一个位置。（删除了一个元素，该元素后面的所有元素都要挪位置，所以，`iter++`，已经指向的是未知内存）。

2. 对于关联容器(如`map`, `set`, `multimap`, `multiset`)，删除当前的`iterator`，仅仅会使当前的`iterator`失效，只要在`erase`时，递增当前`iterator`即可。这是因为`map`之类的容器，使用了**红黑树**来实现，插入、删除一个结点不会对其他结点造成影响。`erase`迭代器只是被删元素的迭代器失效，但是返回值为`void`，所以要采用`erase(iter++)`的方式删除迭代器。

`map`是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。

所以在`map`中为了防止迭代器失效，在有删除操作时，常用如下方法：
```cpp
for (iter = dataMap.begin(); iter != dataMap.end(); )
{
    int nKey = iter->first;
    string strValue = iter->second;
    if (nKey % 2 == 0){
        map<int, string>::iterator tmpIter = iter;
        iter++;
        dataMap.erase(tmpIter);
        //dataMap.erase(iter++) 这样也行

    }
    else{
        iter++;
    }
}
```
+ **数组型数据结构**：该数据结构的元素是分配在连续的内存中，`insert`和`erase`操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说`insert(*iter)`(或`erase(*iter)`)，然后在`iter++`，是没有意义的。解决方法：`erase(*iter)`的返回值是下一个有效迭代器的值: `iter =cont.erase(iter);`

+ **链表型数据结构**：对于`list`型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器，解决办法两种，`erase(*iter)`会返回下一个有效迭代器的值，或者`erase(iter++)`.

+ **树形数据结构**： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器，`erase`迭代器只是被删元素的迭代器失效，但是返回值为`void`，所以要采用`erase(iter++)`的方式删除迭代器。

#### vector迭代器失效
1. 当插入（`push_back`）一个元素后，`end`操作返回的迭代器肯定失效。
2. 当插入(`push_back`)一个元素后，`capacity`返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时`begin`和`end`操作返回的迭代器都会失效。
3. 当进行删除操作（`erase`，`pop_back`）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。

#### deque迭代器失效
1. 在`deque`容器首部或者尾部插入元素不会使得任何迭代器失效。
2. 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。
3. 在`deque`容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。

#### list、set、map迭代器失效
删除时，指向该删除节点的迭代器失效

### 红黑树
红黑树是一种二叉查找树，二叉搜索树的规则是：任何节点的键值一定大于其左子树的每一个节点值，并小于右子树的每一个节点值。
#### 红黑树的规则
1. 节点是红色或黑色。；
2. 根节点是黑色；
3. 每个叶节点（NILL节点，空节点）是黑色的；
4. 每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）；
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

由性质4可以推出：一条路径上不能有两个毗连的红色节点。最短的可能路径都是黑色节点，最长的可能路径是交替的红色和黑色节点。又根据性质5，所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

#### 红黑树的插入 (待补充)

#### 红黑树的删除 (待补充)

#### 红黑树的旋转 (待补充)

## 算法
`STL`中的算法以迭代器为参数，通过作用于迭代器而达到处理容器数据的目的。所有的算法都前两个参数都是以对迭代器（`iterator`），通常称为`first`和`last`。事实上，算法所处理的迭代器范围为[`first`,`last`)，如果`first==last`则表明此范围为空。按照处理问题的不同，`STL`算法可分为四组，分别是：
1. 不改变序列的算法(`None-mutating sequence Algorithm`)
2. 改变序列的算法(`Mutating sequence Algorithm`)
3. 排序以及相关算法(`Sorting and related Algorithm`)
4. 常用数字算法(`Generalized numeric Algorithm`)

### 不改变序列算法
```cpp
adjacent_find   查找两个相邻（Adjacent）的等价（Identical）元素
all_of (C++11)  检测在给定范围中是否所有元素都满足给定的条件
any_of (C++11)  检测在给定范围中是否存在元素满足给定条件
count   返回值等价于给定值的元素的个数
count_if    返回值满足给定条件的元素的个数
equal   返回两个范围是否相等
find    返回第一个值等价于给定值的元素
find_end    查找范围 A 中与范围 B 等价的子范围最后出现的位置
find_first_of   查找范围 A 中第一个与范围 B 中任一元素等价的元素的位置
find_if 返回第一个值满足给定条件的元素
find_if_not (C++11) 返回第一个值不满足给定条件的元素
for_each    对范围中的每个元素调用指定函数
mismatch    返回两个范围中第一个元素不等价的位置
none_of (C++11) 检测在给定范围中是否不存在元素满足给定的条件
search  在范围 A 中查找第一个与范围 B 等价的子范围的位置
search_n    在给定范围中查找第一个连续 n 个元素都等价于给定值的子范围的位置
```

### 修改序列算法
```cpp
copy    将一个范围中的元素拷贝到新的位置处
copy_backward   将一个范围中的元素按逆序拷贝到新的位置处
copy_if (C++11) 将一个范围中满足给定条件的元素拷贝到新的位置处
copy_n (C++11)  拷贝 n 个元素到新的位置处
fill    将一个范围的元素赋值为给定值
fill_n  将某个位置开始的 n 个元素赋值为给定值
generate    将一个函数的执行结果保存到指定范围的元素中，用于批量赋值范围中的元素
generate_n  将一个函数的执行结果保存到指定位置开始的 n 个元素中
iter_swap   交换两个迭代器（Iterator）指向的元素
move (C++11)    将一个范围中的元素移动到新的位置处
move_backward (C++11)   将一个范围中的元素按逆序移动到新的位置处
random_shuffle  随机打乱指定范围中的元素的位置
remove  将一个范围中值等价于给定值的元素删除
remove_if   将一个范围中值满足给定条件的元素删除
remove_copy 拷贝一个范围的元素，将其中值等价于给定值的元素删除
remove_copy_if  拷贝一个范围的元素，将其中值满足给定条件的元素删除
replace 将一个范围中值等价于给定值的元素赋值为新的值
replace_copy    拷贝一个范围的元素，将其中值等价于给定值的元素赋值为新的值
replace_copy_if 拷贝一个范围的元素，将其中值满足给定条件的元素赋值为新的值
replace_if  将一个范围中值满足给定条件的元素赋值为新的值
reverse 反转排序指定范围中的元素
reverse_copy    拷贝指定范围的反转排序结果
rotate  循环移动指定范围中的元素
rotate_copy 拷贝指定范围的循环移动结果
shuffle (C++11) 用指定的随机数引擎随机打乱指定范围中的元素的位置
swap    交换两个对象的值
swap_ranges 交换两个范围的元素
transform   对指定范围中的每个元素调用某个函数以改变元素的值
unique  删除指定范围中的所有连续重复元素，仅仅留下每组等值元素中的第一个元素。
unique_copy 拷贝指定范围的唯一化（参考上述的 unique）结果
```

### 排序及相关算法
+ 排序：
```cpp
is_sorted (C++11)   检测指定范围是否已排序
is_sorted_until (C++11) 返回最大已排序子范围
nth_element 部份排序指定范围中的元素，使得范围按给定位置处的元素划分
partial_sort    部份排序
partial_sort_copy   拷贝部分排序的结果
sort    排序（快速排序）
stable_sort 稳定排序
```

+ 划分：
```cpp
is_partitioned (C++11)  检测某个范围是否按指定谓词（Predicate）划分过
partition   将某个范围划分为两组
partition_copy (C++11)  拷贝指定范围的划分结果
partition_point (C++11) 返回被划分范围的划分点
stable_partition    稳定划分，两组元素各维持相对顺序
```


+ 二分查找：
```cpp
binary_search   判断范围中是否存在值等价于给定值的元素
equal_range 返回范围中值等于给定值的元素组成的子范围
lower_bound 返回指向范围中第一个值大于或等于给定值的元素的迭代器
upper_bound 返回指向范围中第一个值大于给定值的元素的迭代器
```

+ 合并：
```cpp
includes    判断一个集合是否是另一个集合的子集
inplace_merge   就绪合并
merge   合并
set_difference  获得两个集合的差集
set_intersection    获得两个集合的交集
set_symmetric_difference    获得两个集合的对称差
set_union   获得两个集合的并集
```


+ 堆：
```cpp
is_heap 检测给定范围是否满足堆结构
is_heap_until (C++11)   检测给定范围中满足堆结构的最大子范围
make_heap   用给定范围构造出一个堆
pop_heap    从一个堆中删除最大的元素
push_heap   向堆中增加一个元素
sort_heap   将满足堆结构的范围排序
```

### 常用数字算法
```cpp
is_permutation (C++11)  判断一个序列是否是另一个序列的一种排序 
max 返回两个元素中值最大的元素
max_element 返回给定范围中值最大的元素
min 返回两个元素中值最小的元素
min_element 返回给定范围中值最小的元素
minmax (C++11)  返回两个元素中值最大及最小的元素
minmax_element (C++11)  返回给定范围中值最大及最小的元素

lexicographical_compare 比较两个序列的字典序
next_permutation    返回给定范围中的元素组成的下一个按字典序的排列
prev_permutation    返回给定范围中的元素组成的上一个按字典序的排列
```

## 空间配置器

### 为什么？
1. 小块内存会带来内存碎片问题

    如果任由STL中的容器自行通过`malloc`分配内存，那么频繁的分配和释放内存会导致堆中有很多的外部碎片。可能堆中的所有空闲空间之和很大，但当申请新的内存的请求到来时，没有足够大的连续内存可以分配，这将导致内存分配失败。因此这样会导致内存浪费。

2. 小块内存的频繁申请释放会带来性能问题

    开辟空间的时候，分配器需要时间去寻找空闲块，找到空闲块之后才能分配给用户。而如果分配器找不到足够大的空闲块可能还需要考虑处理加碎片现象（释放的小块空间没有合并），这时候需要花时间去合并已经释放了的内存空间块。

    而且`malloc`在开辟内存空间的时候，还会附带附加的额外信息，因为系统需要靠多出来的额外信息管理内存。特别是区块越小，额外负担所占的比例就越大，更加显得浪费。

空间配置器分为两级：
+ 一级空间配置器(`__malloc_alloc_template`):就是直接封装了`malloc()`和`free()`
+ 二级空间配置器(`__default_alloc_template`):根据具体情况采用不同的方法分配空间 
    + 小于128k，有一个内存池和一个自由链表来实现内存的管理
    + 大于128k，调用一级空间配置器

在`STL`中如果你申请的内存大于`128`个字节，那么直接调用一级空间配置器向内存申请内存，如果你申请的内存小于等于`128`个字节，将被认为是小内存，那么将会调用二级空间配置器直接去内存池中申请。


默认情况下使用二级空间配置器，源码中有一个模板类——`simple_alloc`。其中有一个宏——`__USE_MALLOC` ，如果这个宏被定义了，那么就是用一级空间适配器。如果没被定义，那么就是用二级空间适配器。

### 空间配置器的使用
1. 源码中存在一个枚举变量`__MAX_BYTES(128)`来区分大内存块和小内存块，凡是大于`__MAX_BYTES`的内存块都是属于一级空间配置器的管理范畴。
2. 二级空间配置器的底层是由一个`free list`（哈希桶）来管理的。有一个枚举变量`__ALIGN`的值`8`就是表示哈希桶划分的间隔。
3. 二级空间配置器中会有对应算法来计算出最合适的内存块和内存块个数，然后查询哈希桶是否有对应的内存块或者说内存块是否足够，如果没有，向系统询问调整`free list`。

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/kongj01.png)

4. 在`allocate()`函数调用时发现`free list`中没有空间是，便会呼叫`refill()`函数重新填充`free list` —— 去找内存池要。

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/kongji02.png)

新的空间来自哪？——内存池。这部分工作交给`chunk_alloc()`。当然也有可能内存池(`memory pool`)中内存也满足不了要求。

类中利用两个静态指针` start_free` 和 `end_free` 来标识内存池。

`chunk_alloc()`会利用`end_free - start_free`来计算判断内存池的内存量：
+ 如果存在内存但是不够，就先把能给的给出去。
+ 如果存在内存而且够了，直接给不废话。
+ 如果内存是一点都没了，只能重新去`heap`中`malloc`。

5. 山穷水尽——如果真的二级空间配置器一点内存都分配不出来了，那么只能从一级空间配置器中来寻找。

**为什么二级都没有而一级会有呢？**
因为一级中有空间不足时的应对措施，所以就算是失败，也是一级空间配置器来报的错。

**二级空间配置器的释放？**
首先先判断是否大于`128`，如果大于则用一级空间配置器的释放，如果小于则挂回`free list`。

### 一级空间配置器
一级空间配置器只是简单的封装了一下`malloc`和`free`实现的。在`allocate`函数中如果通过`malloc`申请内存失败（失败返回`0`）就改用`oom_malloc`(`size_t n`)函数尝试分配内存，如果`oom`发现没有指定`new-handler`函数的话，那就直接调用`__THROW_BAD_ALLOC`，丢出`bad_alloc`或是直接通过`exit(1)`中止程序。

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/%E4%B8%80%E7%BA%A7.png)

### 二级空间配置器
二级空间配置器使用内存池+自由链表的形式避免了小块内存带来的碎片化，提高了分配的效率，提高了利用率。`SGI`的做法是先判断要开辟的大小是不是大于`128`，如果大于`128`则就认为是一块大块内存，调用一级空间配置器直接分配。否则的话就通过内存池来分配，假设要分配8个字节大小的空间，那么他就会去内存池中分配多个`8`个字节大小的内存块，将多余的挂在自由链表上，下一次再需要`8`个字节时就去自由链表上取就可以了，如果回收这`8`个字节的话，直接将它挂在自由链表上就可以了。

如果不大于就将任何小额区块的内存`__n`上调至`8`的倍数（即使你请求`1`个字节，那也会申请`8`个字节）。这是因为在二级空间配置器中内存是通过`free_list`管理的。

注意这里出现了关键字**voliate**：确保本条指令不会因为编译器的优化而省略，而且要求每次从内存中直接读取值

`free_list`如下图所示，为了便于管理，二级空间配置器在分配的时候都是以8的倍数对齐。因此`free_list`含有`16`个结点，分别管理大小为8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128字节大小的内存。

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/%E4%BA%8C%E7%BA%A701.png)

二级空间配置器的**逻辑步骤**：

假如现在申请`n`个字节：

1. 判断n是否大于128，如果大于128则直接调用一级空间配置器。如果不大于，则将n上调至8的倍数处，然后再去自由链表中相应的结点下面找，如果该结点下面挂有未使用的内存，则摘下来直接返回这块空间的地址。否则的话我们就要调用`refill(size_t n)`函数去内存池中申请。

2. 向内存池申请的时候可以多申请几个，`STL`默认一次申请`nobjs=20`个，将多余的挂在自由链表上，这样能够提高效率。

  进入refill函数后，先调`chunk_alloc(size_t n,size_t& nobjs)`函数去内存池中申请，如果申请成功的话，再回到`refill`函数。

  这时候就有两种情况，如果`nobjs=1`的话则表示内存池只够分配一个，这时候只需要返回这个地址就可以了。否则就表示`nobjs`大于1，则将多余的内存块挂到自由链表上。

  如果`chunk_alloc`失败的话，在他内部有处理机制。

3. 进入`chunk_alloc(size_t n,size_t& nobjs )`向内存池申请空间的话有三种情况：
    +  内存池剩余的空间足够`nobjs*n`这么大的空间，则直接分配好返回就可以了。
    +  内存池剩余的空间`leftAlloc`的范围是`n<=leftAlloc<nobjs*n`,则这时候就分配`nobjs=(leftAlloc)/n`这么多个的空间返回。
    +  内存池中剩余的空间连一个`n`都不够了，这时候就要向`heap`申请内存，不过在申请之前先要将内存池中剩余的内存挂到自由链表上，之后再向`heap`申请。
        +  如果申请成功的话，则就再调一次`chunk_alloc`重新分配。
        +  如果不成功的话，这时候再去自由链表中看看有没有比`n`大的空间，如果有就将这块空间还给内存池，然后再调一次`chunk_alloc`重新分配。
        +  如果没有的话，则就调用一级空间配置器分配，看看内存不足处理机制能否处理。

申请的流程图：
![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/%E4%BA%8C%E7%BA%A702.png)

空间配置器的其他问题：
1. 在空间配置器中所有的函数和变量都是静态的，所以他们在程序结束的时候才会被释放发。二级空间配置器中没有将申请的内存还给操作系统，只是将他们挂在自由链表上。所以说只有当你的程序结束了之后才会将开辟的内存还给操作系统。

2. 由于它没有将内存还给操作系统，所以就会出现二种极端的情况。
    + 假如我不断的开辟小块内存，最后将整个heap上的内存都挂在了自由链表上，但是都没有用这些空间，再想要开辟一个大块内存的话会开辟失败。
    + 再比如我不断的开辟`char`,最后将整个heap内存全挂在了自由链表的第一个结点的后面，这时候我再想开辟一个`16`个字节的内存，也会失败。

    或许我比较杞人忧天吧，总的来说上面的情况只是小概率情况。如果非得想办法解决的话，我想的是：针对第一种情况我们可以引入释放二级空间配置器的方法，但是这个释放比较麻烦。针对第二种我们可以合并自由链表上的连续的小的内存块。

3. 二级空间配置器会造成内碎片问题，极端的情况下一直申请`char`，则就会浪费`7/8`的空间。但是整体来说，空间配置器的性能还是蛮高的。

### 内存池技术
如图所示，自由链表是一个指针数组，有点类似与hash桶，它的数组大小为`16`，每个数组元素代表所挂的区块大小，比如`free _ list[0]`代表下面挂的是`8 bytes`的区块，`free _ list[1]`代表下面挂的是`16 bytes`的区块…….依次类推，直到`free _ list[15]`代表下面挂的是`128 bytes`的区块。

同时我们还有一个被称为内存池地方，以`start _ free`和 `end _ free`记录其大小，用于保存未被挂在自由链表的区块，它和自由链表构成了伙伴系统。

![](https://raw.githubusercontent.com/Hewie8023/VueBlogImg/master/C%2B%2B/%E5%86%85%E5%AD%98%E6%B1%A0.png)

当自由链表中没有对应的内存块，系统会执行以下策略：

如果用户需要是一块n字节的区块，且`n <= 128`（调用第二级配置器），此时`refill`填充是这样的：（需要注意的是：系统会自动将`n`字节扩展到8的倍数也就是`RoundUP（n）`，再将`RoundUP（n）`传给`Refill`）。用户需要`n`块，且自由链表中没有，因此系统会向内存池申请`nobjs * n`大小的内存块，默认`nobjs=20`。
1. 如果内存池大于 `nobjs * n`，那么直接从内存池中取出
2. 如果内存池小于 `nobjs * n`，但是比一块大小n要大，那么此时将内存最大可分配的块数给自由链表，并且更新`nobjs`为最大分配块数`x` （`x < nobjs`）
3. 如果内存池连一个区块的大小`n`都无法提供，那么首先先将内存池残余的零头给挂在自由链表上，然后向系统`heap`申请空间，申请成功则返回，申请失败则到自己的自由链表中看看还有没有可用区块返回，如果连自由链表都没了最后会调用一级配置器

## 仿函数
新名称叫函数对象。

仿函数(`functor`)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个`operator()`，这个类就有了类似函数的行为，就是一个仿函数类了。实际上仿函数对象仅仅占用1字节，因为内部没有数据成员，仅仅是一个重载的方法而已。

**仿函数产生的原因：**
由于函数指针毕竟不能满足`STL`对抽象对象的需求，也不能满足软件积木的需求——函数指针无法和`STL`其它组件（如配接器`adapter`）搭配使用，产生更灵活的变化。
```cpp
struct MyPlus{
    int operator()(const int &a , const int &b) const{
        return a + b;
    }
};

int main()
{
    MyPlus a;
    cout << MyPlus()(1,2) << endl;//1、通过产生临时对象调用重载运算符
    cout << a.operator()(1,2) << endl;//2、通过对象显示调用重载运算符
    cout << a(1,2) << endl;//3、通过对象类似函数调用 隐示地调用重载运算符
    return 0;
}
```
